//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////

#import "LHMouseJointExt.h"
#import "LHSettings.h"
@implementation LevelHelperLoader (MOUSE_JOINT_EXTENSION)
////////////////////////////////////////////////////////////////////////////////
-(bool) isBodyTouched:(b2Body*)body touchPoint:(CGPoint)point
{
    if(body == nil)
        return false;
    
    b2Fixture* stFix = body->GetFixtureList();
    
    while(stFix != 0)
    {
        if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], point.y/[[LHSettings sharedInstance] lhPtmRatio])))
        {
            return true;
        }
        stFix = stFix->GetNext();
    }
    
    return false;    
}
////////////////////////////////////////////////////////////////////////////////
-(bool) isBodyWithUniqueNameTouched:(NSString*)name touchPoint:(CGPoint)point
{
    LHSprite* spr = [self spriteWithUniqueName:name];
    
    if(!spr)
        return false;
    
    b2Body* bd = [spr body];
    return [self isBodyTouched:bd touchPoint:point];
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) bodyWithUniqueName:name touchedAtPoint:(CGPoint*)point withFingerSize:(int)size
{
    
    LHSprite* spr = [self spriteWithUniqueName:name];
    
    if(!spr)
        return NULL;

    b2Body* body = [spr body];
    
	for(int x = -size/2; x < size/2; ++x)
	{
		for(int y = -size/2; y < size/2; ++y)
		{
			CGPoint curPoint = {point->x + x, point->y + y};
			
			if([self isBodyTouched:body touchPoint:curPoint])
			{
				*point = curPoint;
				return body;
			}
		}
	}
    
    return 0;    
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) bodyWithTag:(enum LevelHelper_TAG)tag touchedAtPoint:(CGPoint*)point withFingerSize:(int)size
{
    
    NSArray* sprs  = [self spritesWithTag:tag];
        
    for(LHSprite* spr in sprs)
    {
        b2Body* body = [spr body];
        
        for(int x = -size/2; x < size/2; ++x)
        {
            for(int y = -size/2; y < size/2; ++y)
            {
                CGPoint curPoint = {point->x + x, point->y + y};
                
                if([self isBodyTouched:body touchPoint:curPoint])
                {
                    *point = curPoint;
                    return body;
                }
            }
        }
    }
    
    return 0;    
}
////////////////////////////////////////////////////////////////////////////////
-(b2Body*) bodyWithTag:(enum LevelHelper_TAG)tag touchedAtPoint:(CGPoint)point
{
    NSArray* sprs  = [self spritesWithTag:tag];
    
    for(LHSprite* spr in sprs)
    {
        b2Body* body = [spr body];
		
        if([self isBodyTouched:body touchPoint:point])
        {
            return body;
        }
    }
    
    return 0;
}
////////////////////////////////////////////////////////////////////////////////
-(b2MouseJoint*) mouseJointForBodyA:(b2Body*)wb_Body bodyB:(b2Body*)ourBody touchPoint:(CGPoint)point
{
    if(0 == ourBody)
        return 0;
    
    b2MouseJointDef md;
    md.bodyA = wb_Body;
    md.bodyB = ourBody;
    
    if(nil == md.bodyA)
    {
        NSLog(@"LevelHelper ERROR: in \"mouseJointForBody\" - You need to create physic boundaries - use createPhysicBoundaries method in the \"init\" method and create physic boundaries in your level.");
        
        return 0;
    }
    
    b2Vec2 locationWorld = b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], point.y/[[LHSettings sharedInstance] lhPtmRatio]);
    
    
    md.target = locationWorld;
    md.collideConnected = true;
    md.maxForce = 1000.0f * ourBody->GetMass();
    ourBody->SetAwake(true);
    
    return (b2MouseJoint *)box2dWorld->CreateJoint(&md);
}
////////////////////////////////////////////////////////////////////////////////
-(b2MouseJoint*) mouseJointForBody:(b2Body*)ourBody touchPoint:(CGPoint)point
{
    b2Body* wbBodyB = [self bottomPhysicBoundary];
	if(wbBodyB == NULL)
		return NULL;
	
    return [self mouseJointForBodyA:wbBodyB bodyB:ourBody touchPoint:point];
}
////////////////////////////////////////////////////////////////////////////////
-(b2MouseJoint*) mouseJointForBodyWithUniqueName:(NSString*)name touchPoint:(CGPoint)point
{
    LHSprite* spr = [self spriteWithUniqueName:name];
    
    if(!spr)
        return NULL;
    
    b2Body* ourBody = [spr body];
    
    return [self mouseJointForBody:ourBody touchPoint:point];
}
////////////////////////////////////////////////////////////////////////////////
-(void) setTarget:(CGPoint)point onMouseJoint:(b2MouseJoint*)mouseJoint
{
    if(mouseJoint == 0)
        return;
    b2Vec2 locationWorld = b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], point.y/[[LHSettings sharedInstance] lhPtmRatio]);
    
    mouseJoint->SetTarget(locationWorld);
}
////////////////////////////////////////////////////////////////////////////////
@end
