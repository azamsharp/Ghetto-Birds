//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#import "LHSprite.h"

#import "SHDocumentLoader.h"

#import "LHSettings.h"
#import "LHPathNode.h"
#import "LHParallaxNode.h"
#import "LHAnimationNode.h"
#import "LevelHelperLoader.h"
#import "LHTouchMgr.h"
#import "LHCuttingEngineMgr.h"
#import "LHJoint.h"

#import "LHFixture.h"

#import "LHDictionaryExt.h"

#import "LHCustomClasses.h"


static int untitledSpritesCount = 0;
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
@interface LHJoint (LH_JOINT_SPRITE_EXT) 
@end
@implementation LHJoint (LH_JOINT_SPRITE_EXT)
@end

@interface LHBezier (LH_BEZIER_SPRITE_EXT) 
-(NSArray*)pathPoints;
@end
@implementation LHBezier (LH_BEZIER_SPRITE_EXT)
-(NSArray*)pathPoints{
    return pathPoints;
}
@end


@interface LHSprite (Private)

@end
////////////////////////////////////////////////////////////////////////////////
@implementation LHSprite
@synthesize usesOverloadedTransformations;
@synthesize realScale;
@synthesize swallowTouches;
@synthesize shSceneName;
@synthesize shSheetName;
@synthesize shSpriteName;
////////////////////////////////////////////////////////////////////////////////
//-(oneway void)release{
//    NSLog(@"LHSPrite release %@ %d", uniqueName, [self retainCount]);
//    [super release];
//}

-(void)removeSelf{
    if(body){
        if(body->GetWorld()->IsLocked()){
            [[LHSettings sharedInstance] markSpriteForRemoval:self];
            return;
        }
    }
  //  NSLog(@"SPRITE REMOVE %@ SELF %d", uniqueName, [self retainCount]);
    [self removeFromParentAndCleanup:YES];
}
-(void) onExit{
//    NSLog(@"LH SPrite %@ onExit", uniqueName); 
    [self removeTouchObserver];
}
-(void) dealloc{		
//    NSLog(@"LH Sprite Dealloc %@", uniqueName);
        
    [self removeBodyFromWorld];
    
    
    if(NULL != parallaxFollowingThisSprite)
        [parallaxFollowingThisSprite followSprite:NULL 
                                changePositionOnX:false 
                                changePositionOnY:false];

    if(NULL != spriteIsInParallax){
        [spriteIsInParallax removeChild:self];
        spriteIsInParallax = nil;
    }
                
#ifndef LH_ARC_ENABLED   
    if(fixturesInfo){
        [fixturesInfo release];
        fixturesInfo = nil;
    }
    
    if(animation){
        [animation release];
        animation = nil;
    }

    if(pathNode){
        [pathNode release];
        pathNode = nil;
    }
    
    if(pathDefaultName){
        [pathDefaultName release];
        pathDefaultName = nil;
    }
    
    if(userCustomInfo){
        [userCustomInfo release];
        userCustomInfo = nil;
    }

    if(shSceneName){
        [shSceneName release];
        shSceneName = nil;
    }
    
    [shSheetName release];
    [shSpriteName release];
    
    if(fixturesObj)
        [fixturesObj release];
    
    if(touchBeginObserver)
        [touchBeginObserver release];
    if(touchMovedObserver)
        [touchMovedObserver release];
    if(touchEndedObserver)
        [touchEndedObserver release];
    
    if(imageFile)
        [imageFile release];
        
    [uniqueName release];
#endif    
    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;

#ifndef LH_ARC_ENABLED   
	[super dealloc];
#endif
}
////////////////////////////////////////////////////////////////////////////////
-(void) loadUserCustomInfoFromDictionary:(NSDictionary*)dictionary{
    userCustomInfo = nil;
    if(!dictionary)return;
    
    NSString* className = [dictionary stringForKey:@"ClassName"];
    Class customClass = NSClassFromString(className);

    if(!customClass) return;
    
    userCustomInfo = [customClass performSelector:@selector(customClassInstance)];
#ifndef LH_ARC_ENABLED
    [userCustomInfo retain];
#endif
    [userCustomInfo performSelector:@selector(setPropertiesFromDictionary:) withObject:[dictionary objectForKey:@"ClassRepresentation"]];
}
//------------------------------------------------------------------------------
-(void) createFixturesFromInfoOnBody{
    
    if(fixturesInfo && fixturesObj)
    {
        [fixturesObj removeAllObjects];
        
        if(body->GetWorld()->IsLocked())
        {
            NSLog(@"ERROR: Cannot create fixture for body, because Box2d is Locked. Try changing the location on where you want to change the body. e.g Try doing it at the end of tick function");
            return;
        }
        
        b2Fixture* curFixture = body->GetFixtureList();
        
        while(curFixture)
        {
            b2Fixture* tempNextFix = curFixture->GetNext();
            body->DestroyFixture(curFixture);
            curFixture = tempNextFix;
        }
        
        for(NSDictionary* fixInfo in fixturesInfo)
        {
            LHFixture* lhFixture = [LHFixture fixtureWithDictionary:fixInfo body:body sprite:self];
            [fixturesObj addObject:lhFixture];
        }
    }
}
//------------------------------------------------------------------------------
-(void) loadPhysicalInformationFromDictionary:(NSDictionary*)dictionary{

    body = NULL;
    
    if(nil == dictionary)
        return;
    
    b2World* world = [[LHSettings sharedInstance] activeBox2dWorld];
    NSAssert(world!=nil, @"Box2d World must not be nil");
    
    b2BodyDef bodyDef;	
	
    int pType = [dictionary intForKey:@"Type"];//LH
    
	if(pType == 3) //"NO_PHYSIC"
        return;
    
	bodyDef.type = (b2BodyType)pType;
	
	CGPoint pos = self.position;	
	bodyDef.position.Set(pos.x/[[LHSettings sharedInstance] lhPtmRatio],
                         pos.y/[[LHSettings sharedInstance] lhPtmRatio]);
    
	bodyDef.angle = CC_DEGREES_TO_RADIANS(-1*self.rotation);
    
#ifndef LH_ARC_ENABLED
    bodyDef.userData = self;
#else
    bodyDef.userData = (__bridge void*)self;
#endif
    
    body = world->CreateBody(&bodyDef);    
	body->SetFixedRotation([dictionary boolForKey:@"FixedRot"]);
	        
    body->SetGravityScale([dictionary floatForKey:@"GravityScale"]);
	body->SetSleepingAllowed([dictionary boolForKey:@"CanSleep"]);    
    body->SetBullet([dictionary boolForKey:@"IsBullet"]);

    CGPoint linearVelocity = [dictionary pointForKey:@"LinearVelocity"];
    body->SetLinearVelocity(b2Vec2(linearVelocity.x, linearVelocity.y));
    
    body->SetAngularVelocity([dictionary floatForKey:@"AngularVelocity"]);
    body->SetLinearDamping([dictionary floatForKey:@"LinearDamping"]);
    body->SetAngularDamping([dictionary floatForKey:@"AngularDamping"]);
    
    
    NSArray* fixInfo = [dictionary objectForKey:@"SH_ComplexShapes"];
    fixturesInfo = [[NSArray alloc] initWithArray:fixInfo];
    
    fixturesObj = [[NSMutableArray alloc] init];
    
    [self createFixturesFromInfoOnBody];
    
//    for(NSDictionary* fixInfo in fixturesInfo)
//    {
//        LHFixture* lhFixture = [LHFixture fixtureWithDictionary:fixInfo body:body sprite:self];
//        [fixturesObj addObject:lhFixture];
//    }
}

-(void) loadAnimationsInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(dictionary ==nil) return; //When sprite is loaded from SH dictionary this info is not available;
    
    //if sprite has no animation dictionary will be empty in order to make the level size smaller
    //so we test here to see if we should load anything
    if(![dictionary objectForKey:@"AnimName"]) return;
        
    
    [self prepareAnimationNamed:[dictionary stringForKey:@"AnimName"] 
                    fromSHScene:[dictionary stringForKey:@"SHScene"]];
    
    if(!animation) return;//something has gone wrong with animation loading
    
    if([dictionary boolForKey:@"AnimAtStart"])//we should pause the animation
        [animation play];
    
    [animation setLoop:[dictionary boolForKey:@"AnimLoop"]];
    [animation setRepetitions:[dictionary intForKey:@"AnimRepetitions"]];
    [animation setRestoreOriginalFrame:[dictionary boolForKey:@"AnimRestoreOriginalFrame"]];
    [animation setDelayPerUnit:[dictionary floatForKey:@"AnimSpeed"]];
}

-(void)loadPathMovementFromDictionary:(NSDictionary*)dictionary{
    if(!dictionary)return;
    
    //at this point we may not have a LHBezier in the level 
    //so we create the path after the level is fully loaded
    //but we save the path properties here
    if(![dictionary objectForKey:@"PathName"]) return;
       
    pathDefaultFlipX = [dictionary boolForKey:@"PathFlipX"];
    pathDefaultFlipY = [dictionary boolForKey:@"PathFlipY"];
    pathDefaultIsCyclic = [dictionary boolForKey:@"PathIsCyclic"];
    pathDefaultRelativeMove = [dictionary boolForKey:@"PathMoveDelta"];
    pathDefaultName = [[NSString alloc] initWithString:[dictionary stringForKey:@"PathName"]];
    pathDefaultOrientation = [dictionary intForKey:@"PathOrientation"];
    pathDefaultRestartOtherEnd = [dictionary boolForKey:@"PathOtherEnd"];
    pathDefaultSpeed = [dictionary floatForKey:@"PathSpeed"];
    pathStartAtLaunch= [dictionary boolForKey:@"PathStartAtLaunch"];
    pathDefaultStartPoint = [dictionary intForKey:@"PathStartPoint"];
}

-(void) loadInformationFromDictionary:(NSDictionary*)dictionary{
    
    if(nil != uniqueName)
        return; //compatibility with cocos2d 2.0
    
    if(nil != [dictionary objectForKey:@"UniqueName"]){
        uniqueName = [[NSMutableString alloc] initWithString:[dictionary stringForKey:@"UniqueName"]];
    }else {
        uniqueName = [[NSMutableString alloc] initWithFormat:@"UntitledSprite_%d", untitledSpritesCount];
        ++untitledSpritesCount;
    }
        
    if([dictionary objectForKey:@"SHSceneName"])
        shSceneName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSceneName"]];
    
    if([dictionary objectForKey:@"SHSheetName"])
        shSheetName = [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSheetName"]];
    if([dictionary objectForKey:@"SHSpriteName"])
        shSpriteName= [[NSString alloc] initWithString:[dictionary stringForKey:@"SHSpriteName"]];
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    
    NSDictionary* shTexDict = texDict;
    if(![dictionary objectForKey:@"IsSHSprite"])//we may be loading directly from a sh dictionary
    {
        NSDictionary* shDict = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:[dictionary stringForKey:@"SHSpriteName"]
                                                                          inSheetNamed:[dictionary objectForKey:@"SHSheetName"]
                                                                            inDocument:[dictionary objectForKey:@"SHSceneName"]];

        if(shDict)
            shTexDict = [shDict objectForKey:@"TextureProperties"];
    }
    
    //CGRect rectInPixels = self.textureRect;
    CGRect rectInPixels = [shTexDict rectForKey:@"Frame"];
    
   // [[LHSettings sharedInstance] transformedTextureRect:self.textureRect forImage:[self imageFile]];
    
    rectInPixels = CC_RECT_POINTS_TO_PIXELS(self.textureRect);    
    
    CGSize contentSize = [shTexDict sizeForKey:@"SpriteSize"];
    
    contentSize = [[LHSettings sharedInstance] transformedSize:contentSize forImage:[self imageFile]];
    contentSize.width *= CC_CONTENT_SCALE_FACTOR();
    contentSize.height*= CC_CONTENT_SCALE_FACTOR();
    
    CCSpriteFrame* sprFrame = [CCSpriteFrame frameWithTexture:self.texture
                                                 rectInPixels:rectInPixels
                                                      rotated:[shTexDict boolForKey:@"IsRotated"] 
                                                       offset:[shTexDict pointForKey:@"TextureOffset"]
                                                 originalSize:contentSize];
    
    [self setDisplayFrame:sprFrame];

    CGPoint scale = [texDict pointForKey:@"Scale"];
    
//    CGPoint scale = [[LHSettings sharedInstance] transformedPoint:scaleVal forImage:[self imageFile]];    
    
    bool flipX = [texDict boolForKey:@"FlipX"];
    bool flipY = [texDict boolForKey:@"FlipY"];
    
    [self setFlipX:flipX];
    [self setFlipY:flipY];
    
//    NSLog(@"FLIP %@ x %d y %d", uniqueName, flipX, flipY);

    [self setScaleX:(scale.x)];
    [self setScaleY:(scale.y)];

//    [self setScaleX:(flipX ? -1*scale.x : scale.x)];
//    [self setScaleY:(flipY ? -1*scale.y : scale.y)];
    
    realScale = CGSizeMake(scale.x, scale.y);
//    realScale = CGSizeMake(scaleVal.x*[[LHSettings sharedInstance] convertRatio].x,
//                           scaleVal.y*[[LHSettings sharedInstance] convertRatio].y);
    
    CGPoint position = [[LHSettings sharedInstance] transformedPointToCocos2d:[texDict pointForKey:@"Position"]];
    [self setPosition:ccp((int)position.x, (int)position.y)];
    
    
    [self setRotation:[texDict intForKey:@"Angle"]];
    [self setColor:[texDict colorForKey:@"Color"]];
    [self setVisible:[texDict boolForKey:@"IsDrawable"]];
    [self setOpacity:[texDict floatForKey:@"Opacity"]*255.0f];
    [self setTag:[texDict intForKey:@"Tag"]];
    zOrder_ = [texDict intForKey:@"ZOrder"];
    
    NSDictionary* phyDict = [dictionary objectForKey:@"PhysicProperties"];
    if([phyDict boolForKey:@"HandledBySH"] && ![dictionary objectForKey:@"IsSHSprite"])
    {        
        NSDictionary* sprDict = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:shSpriteName
                                                                               inSheetNamed:shSheetName
                                                                                 inDocument:shSceneName];
        phyDict = [sprDict objectForKey:@"PhysicProperties"];
    }
    
     //we do this because we need the batch to contain the sprite before loading any animation
    if([self batchNode]){
        [[self batchNode] addChild:self z:zOrder_];
    }

    originalRect = self.textureRect;

    [self loadPhysicalInformationFromDictionary:phyDict];    
    [self loadAnimationsInformationFromDictionary:[dictionary objectForKey:@"AnimationsProperties"]];
    
    [self loadUserCustomInfoFromDictionary:[dictionary objectForKey:@"CustomClassInfo"]];
    [self loadPathMovementFromDictionary:[dictionary objectForKey:@"PathProperties"]];
    
    pathNode = nil;
    spriteIsInParallax = nil;
    
    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;
    
    tagTouchBeginObserver = nil;
    tagTouchMovedObserver = nil;
    tagTouchEndedObserver = nil;
    
    usesOverloadedTransformations = false;
    usePhysicsForTouches = true;
        
    [LevelHelperLoader setTouchDispatcherForObject:self tag:[self tag]];
    
    [self scheduleUpdate];
}
-(void)setShSceneName:(NSString *)sceneName
{
    if(shSceneName)
    {
#ifndef LH_ARC_ENABLED
        [shSceneName release];
#endif
    }
    shSceneName = [[NSString alloc] initWithString:sceneName];
}
-(void)setParentLoader:(LevelHelperLoader*)p{
    parentLoader = p;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initBatchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{
        
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = LHRectFromString([texDict objectForKey:@"Frame"]);    

    //NSLog(@"BATCH IMAGE PATH %@", [batch imagePath]);
    
    rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:[batch imagePath]];
        
#if COCOS2D_VERSION >= 0x00020000
    self = [super initWithTexture:[batch texture] rect:rect];
    
    [self setBatchNode:batch];
//    if([self batchNode]){
//        [[self batchNode] addChild:self z:zOrder_];
//    }
#else
    self = [super initWithBatchNode:batch rect:rect];
#endif
    
    if (self != nil){        
        [self setImageFile:[batch imagePath]];        
        [self loadInformationFromDictionary:dictionary];
        
    //    [batch addChild:self];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithDictionary:(NSDictionary*)dictionary batch:(LHBatch*)batch{
#ifndef LH_ARC_ENABLED
    return [[[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    return [[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(id)initWithDictionary:(NSDictionary*)dictionary{
    
    NSString* imgPath = [[LHSettings sharedInstance] imagePath:[dictionary objectForKey:@"SheetImage"]];
    NSAssert(imgPath!=nil, @"Image path must not be nil");
    
    NSDictionary* texDict = [dictionary objectForKey:@"TextureProperties"];
    CGRect rect = LHRectFromString([texDict objectForKey:@"Frame"]);
    
    rect = [[LHSettings sharedInstance] transformedTextureRect:rect forImage:imgPath];
    
    self = [super initWithFile:imgPath rect:rect];    
    if (self != nil){
        [self setImageFile:imgPath];
        [self loadInformationFromDictionary:dictionary];
    }
    return self;
}
//------------------------------------------------------------------------------
+(id)spriteWithDictionary:(NSDictionary*)dictionary{
#ifndef LH_ARC_ENABLED
    return [[[LHSprite alloc] initWithDictionary:dictionary] autorelease];
#else
    return [[LHSprite alloc] initWithDictionary:dictionary];
#endif 
}
-(void)postInit{
    //nothing to do - method provided for overloading sprites
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
+(id)spriteWithName:(NSString*)spriteName 
          fromSheet:(NSString*)sheetName 
             SHFile:(NSString*)spriteHelperFile{

    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:sheetName 
                                                                                inDocument:spriteHelperFile];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initWithDictionary:dictionary] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initWithDictionary:dictionary];
#endif 
    
    if(sprite){      
        [sprite setShSceneName:spriteHelperFile];
    }
    return sprite;
}
//------------------------------------------------------------------------------
+(id)batchSpriteWithName:(NSString*)spriteName 
                   batch:(LHBatch*)batch{
    
    NSAssert(spriteName!=nil, @"Sprite name  must not be nil");
    NSAssert(batch!=nil, @"Batch must not be nil");
        
    NSDictionary* dictionary = [[SHDocumentLoader sharedInstance] dictionaryForSpriteNamed:spriteName 
                                                                              inSheetNamed:[batch uniqueName]
                                                                                inDocument:[batch shFile]];
#ifndef LH_ARC_ENABLED
    LHSprite* sprite = [[[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch] autorelease];
#else
    LHSprite* sprite = [[LHSprite alloc] initBatchSpriteWithDictionary:dictionary batch:batch];
#endif     
    
    if(sprite){
        //[batch addChild:sprite z:[sprite zOrder]];
        [sprite setShSceneName:[batch shFile]];
    }
    return sprite;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) setUniqueName:(NSString*)name{
    NSAssert(name!=nil, @"UniqueName must not be nil");
    [uniqueName setString:name];
}
//------------------------------------------------------------------------------
-(NSString*)uniqueName{
    return uniqueName;   
}
//------------------------------------------------------------------------------
-(void) setBody:(b2Body*)bd{
    NSAssert(bd!=nil, @"b2Body must not be nil");
    body = bd;
}
//------------------------------------------------------------------------------
-(b2Body*)body{
    return body;
}
//------------------------------------------------------------------------------
-(bool) removeBodyFromWorld{
    if(NULL != body){
		b2World* _world = body->GetWorld();
		if(0 != _world){
                       
            NSMutableArray* list = (NSMutableArray*)[self jointList];
            for(LHJoint* jt in list){
                [jt setShouldDestroyJointOnDealloc:NO];
                [jt removeSelf];
            }
            [list removeAllObjects];
            
			_world->DestroyBody(body);
			body = NULL;
            
            return true;
		}
	}
    return false;
}
////////////////////////////////////////////////////////////////////////////////
-(NSString*)imageFile{
    return imageFile;
}
-(void)setImageFile:(NSString*)img{
    
#ifndef LH_ARC_ENABLED
    if(imageFile)
        [imageFile release];
#endif
    
    imageFile = [[NSString alloc] initWithString:img];
}
//------------------------------------------------------------------------------
-(CGRect)originalRect{
    return originalRect;
}
-(void)setOriginalRect:(CGRect)rect{
    originalRect = rect;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)setPosition:(CGPoint)pos
{
    if(usesOverloadedTransformations)
        [self transformPosition:pos];
    else {
        [super setPosition:pos];
    }
}
-(void)setRotation:(float)rot
{
    if(usesOverloadedTransformations)
        [self transformRotation:rot];
    else {
        [super setRotation:rot];
    }
}
//------------------------------------------------------------------------------
-(void)setScale:(float)scale{

    if(usesOverloadedTransformations)
        [self transformScale:scale];
    else {
        [super setScale:scale];
    }
}
-(void)setScaleX:(float)scaleX{
    if(usesOverloadedTransformations)
        [self transformScaleX:scaleX];
    else {
        [super setScaleX:scaleX];
    }
}

-(void)setScaleY:(float)scaleY{
    if(usesOverloadedTransformations)
        [self transformScaleY:scaleY];
    else {
        [super setScaleY:scaleY];
    }
}
//------------------------------------------------------------------------------
-(void) transformPosition:(CGPoint)pos{
    [super setPosition:pos];
    if(0 != body){
        b2Vec2 boxPosition = [LevelHelperLoader pointsToMeters:pos];
        float angle = CC_DEGREES_TO_RADIANS(-1*super.rotation);
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
-(void)transformRotation:(float)rot{
    
    [super setRotation:rot];
    if(0 != body){
        b2Vec2 boxPosition = [LevelHelperLoader pointsToMeters:super.position];
        float angle = CC_DEGREES_TO_RADIANS(-1*rot);
        body->SetTransform(boxPosition, angle);
    }
}
//------------------------------------------------------------------------------
-(void) transformScale:(float)scale{

    [super setScale:scale];
    
    if(0 != body){
        [self createFixturesFromInfoOnBody];
    }
}
-(void) transformScaleX:(float)scaleX{

    [super setScaleX:scaleX];
    
    if(0 != body){
        [self createFixturesFromInfoOnBody];        
    }

}
-(void) transformScaleY:(float)scaleY{
    [super setScaleY:scaleY];
    
    if(0 != body){
        [self createFixturesFromInfoOnBody];
    }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void)update:(ccTime)dt{    
    if(animation)
        [animation update:dt];
    
    if(pathNode)
        [pathNode update:dt];
}
//------------------------------------------------------------------------------
-(void) prepareAnimationNamed:(NSString*)animName fromSHScene:(NSString *)shScene{

    NSDictionary* animDict = [[SHDocumentLoader sharedInstance] dictionaryForAnimationNamed:animName
                                                                                 inDocument:shScene];
    if(animation)
    {
#ifndef LH_ARC_ENABLED
        [animation release];
#endif
        animation = nil;
    }
    
    if(!animDict) {
        NSLog(@"ERROR: SpriteHelper document %@ for animation %@ needs to be updated. Animation is canceled.", shScene, animName);
        return;
    }
        
    NSString* textureFile = [animDict stringForKey:@"SheetImage"];
    NSString* animSheet = [animDict stringForKey:@"SheetName"];

    animation = [[LHAnimationNode alloc] initWithDictionary:animDict 
                                                   onSprite:self];

    if(![shSheetName isEqualToString:animSheet]){
        if(nil != textureFile){
            
#if COCOS2D_VERSION >= 0x00020000
            NSString* filePath = [[CCFileUtils sharedFileUtils] fullPathFromRelativePath:textureFile];
#else
            NSString* filePath = [CCFileUtils fullPathFromRelativePath:textureFile];
#endif
    
            if(filePath){
                CCTexture2D* newTexture = [[CCTextureCache sharedTextureCache] addImage:filePath];
                
                if(newTexture){
                    //if sprite is render by a batch node we need to remove if from the batch and 
                    //move it on the layer that contains the batch
                    LHBatch* parentBatch = (LHBatch*)[self batchNode];
                        
                    if(parentBatch){                       
                        [self removeFromParentAndCleanup:NO];
                        
                        [animation setOldBatch:parentBatch];
                        //we need to keep the z order so its batch z + sprite z 
                        if([parentBatch parent]){                            
                            [[parentBatch parent] addChild:self z:[parentBatch zOrder] + [self zOrder]];
                        }
                        else {
                            NSLog(@"ERROR: Sprite is render by batch node, but batch node has no parent.");
                        }
                    }   
                    else {
                        [animation setOldTexture:self.texture];
                    }
                    
                    [self setTexture:newTexture];
                    #ifndef LH_ARC_ENABLED
                    [shSheetName release];
                    #endif
                    shSheetName = [[NSString alloc] initWithString:animSheet];
                }
            }
        }
        else{
            #ifndef LH_ARC_ENABLED
            [animation release];
            #endif
            NSLog(@"ERROR: Image file %@ could not be found. Please add it in the resource folder.", textureFile);
        }
    }

    if(animation){
        [animation setOldRect:originalRect];
        [animation prepare];
    
    }
}
//------------------------------------------------------------------------------
-(void) playAnimation{ if(animation)[animation play];}
//------------------------------------------------------------------------------
-(void) pauseAnimation{ if(animation)[animation setPaused:YES];}
//------------------------------------------------------------------------------
-(void) restartAnimation{ if(animation)[animation setPaused:YES];}
//------------------------------------------------------------------------------
-(bool) isAnimationPaused{ if(!animation)return false;
    return [animation paused];
}
//------------------------------------------------------------------------------
-(void) stopAnimation{

    if(!animation)return;

    [animation restoreFrame];

    #ifndef LH_ARC_ENABLED
    [animation release];
    #endif
    animation = nil;
}
//------------------------------------------------------------------------------
-(NSString*) animationName{ if(animation) return [animation uniqueName];
    return @"";
}
//------------------------------------------------------------------------------
-(int) numberOfFrames{ if(animation)return [animation numberOfFrames];    
    return -1;
}
//------------------------------------------------------------------------------
-(float) animationDelayPerUnit{
    if(animation){return [animation delayPerUnit];}
    return 0.0f;
}
-(void) setAnimationDelayPerUnit:(float)d{
    if(animation){ if(d < 0.0f) d = 0.0f; [animation setDelayPerUnit:d];}
}
//------------------------------------------------------------------------------
-(float)animationDuration{
    if(animation)return [animation totalTime];
    return 0.0f;
}
//------------------------------------------------------------------------------
-(void) setFrame:(int)frmNo{ if(animation)[animation setFrame:frmNo];}
//------------------------------------------------------------------------------
-(int) currentFrame{     
    if(animation) return [animation currentFrame];    
    return -1;
}
//------------------------------------------------------------------------------
-(void) nextFrame{ if(animation)[animation nextFrame];}
//------------------------------------------------------------------------------
-(void) prevFrame{ if(animation)[animation prevFrame];}
//------------------------------------------------------------------------------
-(void) nextFrameAndRepeat{ if(animation)[animation nextFrameAndRepeat];}
//------------------------------------------------------------------------------
-(void) prevFrameAndRepeat{ if(animation)[animation prevFrameAndRepeat];}
//------------------------------------------------------------------------------
-(bool) isAtLastFrame{ if(animation)return [animation isAtLastFrame];
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(NSString*)userInfoClassName{
    if(userCustomInfo)
        return NSStringFromClass([userCustomInfo class]);
    return @"No Class";
}
//------------------------------------------------------------------------------
-(id)userInfo{
    return userCustomInfo;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(NSArray*) jointList{
    NSMutableArray* array = [NSMutableArray array];
    if(body != NULL){
        b2JointEdge* jtList = body->GetJointList();
        while (jtList) {
            LHJoint* lhJt = [LHJoint jointFromBox2dJoint:jtList->joint];
            if(lhJt != NULL)
                [array addObject:lhJt];
            jtList = jtList->next;
        }
    }
    return array;
}
//------------------------------------------------------------------------------
-(LHJoint*) jointWithUniqueName:(NSString*)name{
    if(name == nil) return nil;
    NSArray* jointList = [self jointList];
    for(LHJoint* jt in jointList){
        if([[jt uniqueName] isEqualToString:name]){
            return jt;
        }
    }
    return nil;
}
//------------------------------------------------------------------------------
-(bool) removeAllAttachedJoints{
    NSArray* list = [self jointList];
    if(list){
        for(LHJoint* jt in list){
            [jt removeSelf];
        }
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
-(bool) removeJoint:(LHJoint*)joint{
    NSMutableArray* list = (NSMutableArray*)[self jointList];
    if(list){
        for(LHJoint* jt in list){
            if(jt == joint){
                [jt removeSelf];
                return true;
            }
        }
    }    
    NSLog(@"WARNING: Trying to remove joint %@ from the sprite %@ but the joint does not belong to that sprite. Removal of joint was not performed.", [joint uniqueName], uniqueName);
    return false;
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
-(void) prepareMovementOnPathWithUniqueName:(NSString*)pathName{
     NSAssert(pathName!=nil, @"UniqueName must not be nil");

    NSArray* allLayers = [[LHSettings sharedInstance] allLHMainLayers];

    LHBezier* bezier = nil;
    for(LHLayer* layer in allLayers){
        bezier = [layer bezierWithUniqueName:pathName];
        if(bezier)
            break;
    }
    if(bezier){
        pathNode = [[LHPathNode alloc] initPathNodeWithPoints:[bezier pathPoints] 
                                                     onSprite:self];
        [pathNode setPaused:YES];
        
        if(pathDefaultName)
        {
            #ifndef LH_ARC_ENABLED
            [pathDefaultName release];
            #endif
        }
        
        pathDefaultName = [[NSString alloc] initWithString:pathName];
        [pathNode setFlipX:pathDefaultFlipX];
        [pathNode setFlipY:pathDefaultFlipY];
        [pathNode setIsCyclic:pathDefaultIsCyclic];
        [pathNode setRelativeMovement:pathDefaultRelativeMove];
        [pathNode setAxisOrientation:pathDefaultOrientation];
        [pathNode setRestartOtherEnd:pathDefaultRestartOtherEnd];
        [pathNode setSpeed:pathDefaultSpeed];
        [pathNode setStartAtEndPoint:pathDefaultStartPoint];
    }
}

-(NSString*) pathUniqueName{
    return pathDefaultName;
}

-(void) startPathMovement{
    if(pathNode)[pathNode setPaused:NO];
}
-(void) pausePathMovement{
    if(pathNode)[pathNode setPaused:YES];
}
-(void) restartPathMovement{
    if(pathNode)[pathNode restart];
}
-(void) stopPathMovement{
    if(pathNode){
        #ifndef LH_ARC_ENABLED
        [pathNode release]; 
        #endif
        pathNode = nil;
    }
}
-(void) setPathMovementSpeed:(float)value{
    if(pathNode)[pathNode setSpeed:value];
}
-(float)pathMovementSpeed{
    if(pathNode)return [pathNode speed];
    return 0.0f;
}
-(void) setPathMovementStartPoint:(enum LH_PATH_MOVEMENT_START_POINT)point{
    if(!pathNode)return;
    [pathNode setStartAtEndPoint:(bool)point];
}
-(enum LH_PATH_MOVEMENT_START_POINT) pathMovementStartPoint{
    if(!pathNode)return  LH_PATH_INVALID_POINT;
    return (enum LH_PATH_MOVEMENT_START_POINT)[pathNode startAtEndPoint];
}
-(void) setPathMovementIsCyclic:(bool)cyclic{
    
}
-(bool) pathMovementIsCyclic{
    if(!pathNode)return false;
    return [pathNode isCyclic];
}
-(void) setPathMovementRestartsAtOtherEnd:(bool)otherEnd{
    if(pathNode)[pathNode setRestartOtherEnd:otherEnd];
}
-(bool) pathMovementRestartsAtOtherEnd{
    if(!pathNode)return false;
    return [pathNode restartOtherEnd];
}
-(void) setPathMovementOrientation:(enum LH_PATH_MOVEMENT_ORIENTATION)point{
    if(pathNode)[pathNode setAxisOrientation:(int)point];
}
-(enum LH_PATH_MOVEMENT_ORIENTATION) pathMovementOrientation{
    if(!pathNode)return LH_INVALID_ORIENTATION;
    return (enum LH_PATH_MOVEMENT_ORIENTATION)[pathNode axisOrientation];
}
-(void) setPathMovementFlipXAtEnd:(bool)flip{
    if(pathNode)[pathNode setFlipX:flip];
}
-(bool) pathMovementFlipXAtEnd{
    if(!pathNode)return false;
    return [pathNode flipX];
}
-(void) setPathMovementFlipYAtEnd:(bool)flip{
    if(pathNode)[pathNode setFlipY:flip];    
}
-(bool) pathMovementFlipYAtEnd{
    if(!pathNode)return false;
    return [pathNode flipY];
}
-(void) setPathMovementRelative:(bool)rel{
    if(pathNode)[pathNode setRelativeMovement:rel];
}
-(bool) pathMovementRelative{
    if(!pathNode)return false;
    return [pathNode relativeMovement];
}
//-(void) moveOnPathWithUniqueName:(NSString*)pathName 
//                           speed:(float)pathSpeed 
//                 startAtEndPoint:(bool)startAtEndPoint
//                        isCyclic:(bool)isCyclic
//               restartAtOtherEnd:(bool)restartOtherEnd
//                 axisOrientation:(int)axis
//                           flipX:(bool)flipx
//                           flipY:(bool)flipy
//                   deltaMovement:(bool)dMove
//                  endObserverObj:(id)obj 
//                  endObserverSel:(SEL)sel
//{
//    
//    if(pathName == nil)
//        return;
//
//	//already moving on a path so lets cancel that path movement
//    [self cancelPathMovement];
//    
//	LHBezierNode* node = [parentLoader bezierNodeWithUniqueName:pathName];
//	
//	if(nil != node)
//	{
//		LHPathNode* pNode = [node addSpriteOnPath:self
//                                            speed:pathSpeed
//                                  startAtEndPoint:startAtEndPoint
//                                         isCyclic:isCyclic 
//                                restartAtOtherEnd:restartOtherEnd
//                                  axisOrientation:axis
//                                            flipX:flipx
//                                            flipY:flipy
//                                    deltaMovement:dMove];
//        
//        if(nil != pNode){
//            [pNode setPathNotifierObject:obj];
//            [pNode setPathNotifierSelector:sel];
//        }
//        pathNode = pNode;
//        
//#ifndef LH_ARC_ENABLED
//        [pathNode retain];
//#endif
//	}
//}
////------------------------------------------------------------------------------
//-(void) cancelPathMovement{
//    if(nil != pathNode){
//        [pathNode removeFromParentAndCleanup:YES];
//        pathNode = nil;
//    }
//}
////------------------------------------------------------------------------------
//-(void) pausePathMovement:(bool)pauseStatus
//{
//    if(nil != pathNode){
//        [pathNode setPaused:pauseStatus];
//    }
//}
////------------------------------------------------------------------------------
//-(void) setPathSpeed:(float)value{
//    if(pathNode != nil){
//        [pathNode setSpeed:value];
//    }
//}
////------------------------------------------------------------------------------
//-(float) pathSpeed{
//    if(pathNode != nil){
//        return [pathNode speed];
//    }
//    return 0;
//}
////------------------------------------------------------------------------------
//-(void) setPathNode:(LHPathNode*)node{
//    //NSAssert(node!=nil, @"LHPathNode must not be nil");    
//    pathNode = node;
//}
////------------------------------------------------------------------------------
//-(LHPathNode*)pathNode{
//    return pathNode;
//}
////////////////////////////////////////////////////////////////////////////////
-(bool)isTouchedAtPoint:(CGPoint)point{
    
    if(body == NULL || !usePhysicsForTouches)
    {
        float x = point.x;
        float y = point.y;

        float ax = quad_.tl.vertices.x/CC_CONTENT_SCALE_FACTOR();
        float ay = quad_.tl.vertices.y/CC_CONTENT_SCALE_FACTOR();
        
        float bx = quad_.tr.vertices.x/CC_CONTENT_SCALE_FACTOR();
        float by = quad_.tr.vertices.y/CC_CONTENT_SCALE_FACTOR();
        
        float dx = quad_.bl.vertices.x/CC_CONTENT_SCALE_FACTOR();
        float dy = quad_.bl.vertices.y/CC_CONTENT_SCALE_FACTOR();
                
#if COCOS2D_VERSION >= 0x00020000
        if(!self.batchNode)
#else
        if(!self.usesBatchNode)
#endif
        {
            ax += self.position.x;
            ay += self.position.y; 
            
            bx += self.position.x;
            by += self.position.y;
            
            dx += self.position.x;
            dy += self.position.y;
            
        }
        
        float bax=bx-ax;
        float bay=by-ay;
        float dax=dx-ax;
        float day=dy-ay;
        
        if ((x-ax)*bax+(y-ay)*bay<0.0) return false;
        if ((x-bx)*bax+(y-by)*bay>0.0) return false;
        if ((x-ax)*dax+(y-ay)*day<0.0) return false;
        if ((x-dx)*dax+(y-dy)*day>0.0) return false;
        
        return true;

    }
    else{
        b2Fixture* stFix = body->GetFixtureList();
        while(stFix != 0){
            if(stFix->TestPoint(b2Vec2(point.x/[[LHSettings sharedInstance] lhPtmRatio], 
                                       point.y/[[LHSettings sharedInstance] lhPtmRatio]))){
                return true;
            }
            stFix = stFix->GetNext();
        }
    }
    return false;    
}
-(void)setUsePhysicsForTouches:(bool)val{
    usePhysicsForTouches = val;
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
-(void)registerTouchBeginObserver:(id)observer selector:(SEL)selector{
    if(nil == touchBeginObserver)
        touchBeginObserver = [LHObserverPair observerPair];
    
    touchBeginObserver.object = observer;
    touchBeginObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchBeginObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchMovedObserver:(id)observer selector:(SEL)selector{
    if(nil == touchMovedObserver)
        touchMovedObserver = [LHObserverPair observerPair];
    
    touchMovedObserver.object = observer;
    touchMovedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [touchMovedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerTouchEndedObserver:(id)observer selector:(SEL)selector{
    if(nil == touchEndedObserver)
        touchEndedObserver = [LHObserverPair observerPair];
    
    touchEndedObserver.object = observer;
    touchEndedObserver.selector = selector;    
#ifndef LH_ARC_ENABLED
    [touchEndedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)removeTouchObserver
{
#ifndef LH_ARC_ENABLED    
    [touchBeginObserver release];
    [touchMovedObserver release];
    [touchEndedObserver release];
#endif

    touchBeginObserver = nil;
    touchMovedObserver = nil;
    touchEndedObserver = nil;
    
    [LevelHelperLoader removeTouchDispatcherFromObject:self];
}
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __MAC_OS_X_VERSION_MAX_ALLOWED
//for left mouse events use the touch observers from above 
-(void)registerRightMouseDownObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDownObserver)
        rightMouseDownObserver = [LHObserverPair observerPair];
    
    rightMouseDownObserver.object = observer;
    rightMouseDownObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDownObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseDraggedObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseDraggedObserver)
        rightMouseDraggedObserver = [LHObserverPair observerPair];
    
    rightMouseDraggedObserver.object = observer;
    rightMouseDraggedObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseDraggedObserver retain];
#endif
}
//------------------------------------------------------------------------------
-(void)registerRightMouseUpObserver:(id)observer selector:(SEL)selector{
    if(nil == rightMouseUpObserver)
        rightMouseUpObserver = [LHObserverPair observerPair];
    
    rightMouseUpObserver.object = observer;
    rightMouseUpObserver.selector = selector;
#ifndef LH_ARC_ENABLED
    [rightMouseUpObserver retain];
#endif    
}
#endif

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
-(CGPoint)convertedPoint:(CGPoint)touchPoint{
    touchPoint=  [[CCDirector sharedDirector] convertToGL:touchPoint];    
    
    CCNode* prevParent = nil;
    CCNode* layerParent = self.parent;
    
    while(layerParent){
        if(layerParent.parent){
            prevParent = layerParent;
            layerParent = layerParent.parent;
        }
        else{
            layerParent = prevParent;
            break;
        }
    }
    
    if(layerParent){
        touchPoint.x -= layerParent.position.x;
        touchPoint.y -= layerParent.position.y;
    }
    return touchPoint;
}
//------------------------------------------------------------------------------
- (BOOL)ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event{
   
    if(self == nil)
        return NO;
    
    if(nil == touchBeginObserver && nil == tagTouchBeginObserver)
        return false;
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint = [self convertedPoint:touchPoint];
        
    if([self isTouchedAtPoint:touchPoint])
    {
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = touch;
        info.sprite = self;
        info.delta = CGPointZero;

        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 
        return true;
    }
    return false;
}
//------------------------------------------------------------------------------
- (void)ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event{  
    
    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint = [self convertedPoint:touchPoint];
        
    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [self convertedPoint:prevLocation];

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.sprite = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 
}
//------------------------------------------------------------------------------
- (void)ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event{

    CGPoint touchPoint = [touch locationInView:[touch view]];
    touchPoint= [self convertedPoint:touchPoint];

    CGPoint prevLocation = [touch previousLocationInView:[touch view]];
    prevLocation = [self convertedPoint:prevLocation];

    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = touch;
    info.sprite = self;
    info.delta = CGPointMake(touchPoint.x - prevLocation.x,
                             touchPoint.y - prevLocation.y);

    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 
}

- (void)ccTouchCancelled:(UITouch *)touch withEvent:(UIEvent *)event{
}
//------------------------------------------------------------------------------
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
//------------------------------------------------------------------------------
-(CGPoint)convertedEvent:(NSEvent*)event{
    CGPoint touchPoint = [(CCDirectorMac*)[CCDirector sharedDirector] convertEventToGL:event];
    
    CCNode* prevParent = nil;
    CCNode* layerParent = self.parent;
    
    while(layerParent){
        if(layerParent.parent){
            prevParent = layerParent;
            layerParent = layerParent.parent;
        }
        else{
            layerParent = prevParent;
            break;
        }
    }
    
    if(layerParent){
        touchPoint.x -= layerParent.position.x;
        touchPoint.y -= layerParent.position.y;
    }
    return touchPoint;
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDown:(NSEvent*)event{   
    
    CGPoint touchPoint = [self convertedEvent:event];
        
    if([self isTouchedAtPoint:touchPoint])
    {
        mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.sprite = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:touchBeginObserver object:info];
        [LHObserverPair performObserverPair:tagTouchBeginObserver object:info]; 

        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseDragged:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
            
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchMovedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchMovedObserver object:info]; 

    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccMouseUp:(NSEvent*)event{
    
    if(!mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:touchEndedObserver object:info];
    [LHObserverPair performObserverPair:tagTouchEndedObserver object:info]; 

    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDown:(NSEvent*)event{
    
    CGPoint touchPoint = [self convertedEvent:event];
    
    if([self isTouchedAtPoint:touchPoint])
    {
        r_mouseDownStarted = true;
        LHTouchInfo* info = [LHTouchInfo touchInfo];
        info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                         touchPoint.y - self.position.y);
        info.glPoint = touchPoint;
        info.event = event;
        info.touch = nil;
        info.sprite = self;
        info.delta = CGPointZero;
        
        [LHObserverPair performObserverPair:rightMouseDownObserver object:info];
        [LHObserverPair performObserverPair:tagRightMouseDownObserver object:info]; 
        
        return swallowTouches;
    }
    return NO;
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseDragged:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseDraggedObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseDraggedObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}
//------------------------------------------------------------------------------
-(BOOL) ccRightMouseUp:(NSEvent*)event{
    
    if(!r_mouseDownStarted)
        return NO;

    CGPoint touchPoint = [self convertedEvent:event];
        
    r_mouseDownStarted = false;
    LHTouchInfo* info = [LHTouchInfo touchInfo];
    info.relativePoint = CGPointMake(touchPoint.x - self.position.x,
                                     touchPoint.y - self.position.y);
    info.glPoint = touchPoint;
    info.event = event;
    info.touch = nil;
    info.sprite = self;
    info.delta = CGPointMake([event deltaX], [event deltaY]);
    
    [LHObserverPair performObserverPair:rightMouseUpObserver object:info];
    [LHObserverPair performObserverPair:tagRightMouseUpObserver object:info]; 
    
    return swallowTouches;//avoid propagation
}

#endif

////////////////////////////////////////////////////////////////////////////////
+(NSString*) uniqueNameForBody:(b2Body*)body{
    
#ifndef LH_ARC_ENABLED
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return [spr uniqueName];
    
    if([LHBezier isLHBezier:spr])
        return [spr uniqueName];
    
    return nil;
}
//------------------------------------------------------------------------------
+(LHSprite*) spriteForBody:(b2Body*)body
{
    if(0 == body)
        return nil;
#ifndef LH_ARC_ENABLED 
    id spr = (id)body->GetUserData();
#else
    id spr = (__bridge id)body->GetUserData();
#endif
    
    if([LHSprite isLHSprite:spr])
        return spr;
    
    return nil;    
}
//------------------------------------------------------------------------------
+(int) tagForBody:(b2Body*)body{
    if(0 != body){
        #ifndef LH_ARC_ENABLED 
        CCNode* spr = (CCNode*)body->GetUserData();
        #else
        CCNode* spr = (__bridge CCNode*)body->GetUserData();
        #endif
        if(nil != spr){
            return [spr tag];
        }
    }
    return -1;
}
//------------------------------------------------------------------------------
+(bool) isLHSprite:(id)object{
    if([object isKindOfClass:[LHSprite class]]){
        return true;
    }
    return false;
}
////////////////////////////////////////////////////////////////////////////////
- (NSComparisonResult)sortAscending:(LHSprite *)other{

    if(nil == other)
        return NSOrderedSame;
    
    return [uniqueName compare:[other uniqueName]];
}
//------------------------------------------------------------------------------
- (NSComparisonResult)sortDescending:(LHSprite *)other
{		
    if(nil == other)
        return NSOrderedSame;

    NSComparisonResult result = [uniqueName compare:[other uniqueName]];
    
    if(result == NSOrderedDescending)
        return NSOrderedAscending;
    else if(result == NSOrderedAscending)
        return NSOrderedDescending;
    
    return NSOrderedSame;           
}
//------------------------------------------------------------------------------
-(void)setCollisionFilterCategory:(int)category{
    if(body == nil)
        return;
    
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();

        b2Filter filter;
        filter.categoryBits = category;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = curFilter.groupIndex;

        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterMask:(int)mask{
    if(body == nil)
        return;

    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = mask;
        filter.groupIndex   = curFilter.groupIndex;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}
-(void)setCollisionFilterGroup:(int)group{
    if(body == nil)
        return;
    b2Fixture* curFix = body->GetFixtureList();
    while (curFix) {
        
        b2Filter curFilter = curFix->GetFilterData();
        
        b2Filter filter;
        filter.categoryBits = curFilter.categoryBits;
        filter.maskBits     = curFilter.maskBits;
        filter.groupIndex   = group;
        
        curFix->SetFilterData(filter);        
        curFix = curFix->GetNext();
    }
}

//TYPE CONVERSION
//------------------------------------------------------------------------------
-(void)makeDynamic{
    
    if(body == nil)
        return;
    
    body->SetType(b2_dynamicBody);    
}
-(void)makeStatic{
    if(body == nil)
        return;
    
    body->SetType(b2_staticBody);
}
-(void)makeKinematic{
    if(body == nil)
        return;

    body->SetType(b2_kinematicBody);
}
//------------------------------------------------------------------------------
@end
